# -*- coding: utf-8 -*-
"""BIORXIV Code: QEEECAA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gztbJvs5FH5qFjwzDGgZDqpQRRHUvK39
"""

"""
Code accompanying:
  Vohra, S. "Quantifying Energy-Efficient Evolution in Cursorial Avian Archosaurs..."
Version 1
Usage:
  python qeeecaa_code.py
"""
import numpy as np
import math

class Animal:
  """
    Represents a simplified 2D hindlimb model for torque analysis.
  """
  def __init__(self, femur_length = 1.0, tibia_length = 1.71850, met_length = 1.53003, pha_length =0.51851, CoP_fraction = .5, GRF = 1, thetaH = 35, thetaA = 10, thetaMTP = -10, CoMx = -.08, CoMy = .30, patellar_tendon_MA = .09):
    self.femur_length = femur_length
    self.tibia_length = tibia_length
    self.met_length = met_length
    self.pha_length = pha_length
    self.CoP_fraction = CoP_fraction
    self.GRF = GRF
    self.thetaH = thetaH
    self.thetaA = thetaA
    self.thetaMTP = thetaMTP
    self.patellar_tendon_MA = patellar_tendon_MA
    self.CoMx = CoMx
    self.CoMy = CoMy

  def compute_torque(self, th_k_deg):
    # --- 1) Converting all angles to radians ---
    th_h   = math.radians(self.thetaH)       # hip absolute (deg -> rad)
    th_k   = math.radians(th_k_deg)          # knee flexion (deg -> rad)
    th_a   = math.radians(self.thetaA)       # ankle flexion (deg -> rad)
    th_mtp = math.radians(self.thetaMTP)     # MTP flexion (deg -> rad)

    # --- 2) Absolute segment angles ---
    th_tib = th_h - th_k
    th_met = th_tib - th_a
    th_pha = th_met - th_mtp
    #-------
    p_k   = np.array([ self.femur_length*math.cos(th_h),
                       self.femur_length*math.sin(th_h) ], dtype=float)

    p_a = p_k + (np.array([ self.tibia_length*math.cos(th_tib),
                          self.tibia_length*math.sin(th_tib) ], dtype=float))


    p_mtp = p_a + (np.array([ self.met_length*math.cos(th_met),
                          self.met_length*math.sin(th_met) ], dtype=float))

    p_CoP = p_mtp + (np.array([ self.CoP_fraction*self.pha_length*math.cos(th_pha),
                            self.CoP_fraction*self.pha_length*math.sin(th_pha) ], dtype=float))

    #------
    # Intermediate varibale definition and calculations for m_req extraction
    y_CoP = p_CoP[1]
    x_CoP = p_CoP[0]
    phi = math.atan2(self.CoMy - y_CoP, self.CoMx - x_CoP)
    rk = p_CoP - p_k
    y_rk = rk[1] # Access the y-component of rk
    x_rk = rk[0] # Access the x-component of rk

    GRF_force_x = self.GRF*math.cos(phi)
    GRF_force_y = self.GRF*math.sin(phi)

    m_ext = (x_rk*GRF_force_y - y_rk*GRF_force_x)
    m_req = -m_ext

    return(m_req)

import numpy as np
import matplotlib.pyplot as plt

# --- 1. Model Setup (Dein) ---
# Grid definition (2D sweep)
angles_k = np.linspace(30, 140, 222)  #knee angle θ_k (deg); sweeping 30-140, with 222 increments
ankles_a = np.linspace(0, 70, 142)    #ankle angle θ_a (deg); sweeping 0-70, with 142 increments

# Dein-like parameters
dein = Animal(
    femur_length=1.0, tibia_length=1.31242, met_length=0.46217, pha_length=0.41785,
    thetaH=25, CoP_fraction=0.6,  # Base geometry and angles
    CoMx=-.05, CoMy=0.25,         # Dein CoM
    patellar_tendon_MA=0.0656     # Patellar Tendon MA fraction
)

# --- 2. Passive Torque Parameters ---
# These are calculated OUTSIDE the function, as they depend only on the sweep angle th.
k1, k3, knee_rest = 0.7, .1, 55.0 # Passive stiffness constants and rest angle

# Z[i,j] = F_quad at (θ_k = angles_k[i], θ_a = ankles_a[j])
Z = np.zeros((len(angles_k), len(ankles_a)))

# --- 3. Sweep and Calculation Loop ---
for i, th_k_deg in enumerate(angles_k):
    for j, th_a_deg in enumerate(ankles_a):
        # Update the ankle angle for the current sweep iteration
        dein.thetaA = float(th_a_deg)

        # Calculate M_req (External Torque only)
        M_req_ext = dein.compute_torque(th_k_deg)

        # Calculate Passive Torque
        d_deg = th_k_deg - knee_rest
        d_rad = np.radians(d_deg) # NOTE: Passive torque models are usually based on angular deviation (radians)
        M_passive = k1 * d_rad + k3 * (d_rad**3)

        # Total extensor moment that must be provided actively by muscle
        M_total = M_req_ext - M_passive # Required muscle moment must balance M_req_ext AND M_passive

        # Required Quadriceps Force (F_quad)
        F_quad = abs(M_total) / dein.patellar_tendon_MA

        Z[i, j] = F_quad

# --- 4. Plotting ---
plt.figure(figsize=(9,7))
im = plt.imshow(
    Z.T, # Transpose to put theta_a on the y-axis
    extent=[angles_k[0], angles_k[-1], ankles_a[0], ankles_a[-1]],
    origin='lower', aspect='auto',
    vmin=0, vmax=10, cmap='viridis') # Using 'viridis' for high contrast

plt.colorbar(im, label="$F_{\\text{quad}}$ (Force in units of Body Weight, $F/BW$)")
plt.xlabel("Knee Angle $\\theta_k$ ($^\circ$)")
plt.ylabel("Ankle Angle $\\theta_a$ ($^\circ$)")
plt.title("Required Quadriceps Force (D. antirrhopus Model) for Static Stance")
plt.tight_layout()
plt.show()
min_idx = np.unravel_index(np.argmin(Z), Z.shape)
print("Optimal knee angle:", angles_k[min_idx[0]], "Optimal ankle angle:", ankles_a[min_idx[1]])

import numpy as np
import matplotlib.pyplot as plt

# --- 1. Model Setup (Ostrich) ---
angles_k = np.linspace(0, 140, 182)
ankles_a = np.linspace(0, 70, 142)

# Ostrich-like parameters
ost = Animal(
    femur_length=1.0, tibia_length=1.71850, met_length=1.53003, pha_length=0.51851,
    thetaH=35, CoP_fraction=0.5,
    CoMx=0.08, CoMy=0.30,        # Ostrich CoM (0.08 Lf, 0.3 Lf)
    patellar_tendon_MA=0.09
)

# --- 2. Passive Torque Parameters ---
# Edit parameters here (!)
k1, k3, knee_rest = 0.6, .1, 32.0


Z = np.zeros((len(angles_k), len(ankles_a)))

# --- 3. Sweep and Calculation Loop ---
for i, th_k_deg in enumerate(angles_k):
    for j, th_a_deg in enumerate(ankles_a):
        ost.thetaA = float(th_a_deg)

        M_req_ext = ost.compute_torque(th_k_deg)

        d_deg = th_k_deg - knee_rest
        d_rad = np.radians(d_deg)
        M_passive = k1 * d_rad + k3 * (d_rad**3)

        M_total = M_req_ext - M_passive
        F_quad = abs(M_total) / ost.patellar_tendon_MA

        Z[i, j] = F_quad

# --- 4. Plotting ---
plt.figure(figsize=(9,7))
im = plt.imshow(
    Z.T,
    extent=[angles_k[0], angles_k[-1], ankles_a[0], ankles_a[-1]],
    origin='lower', aspect='auto',
    vmin=0, vmax=10, cmap='viridis')

plt.colorbar(im, label="$F_{\\text{quad}}$ (Force in units of Body Weight, $F/BW$)")
plt.xlabel("Knee Angle $\\theta_k$ ($^\circ$)")
plt.ylabel("Ankle Angle $\\theta_a$ ($^\circ$)")
plt.title("Required Quadriceps Force (S. camelus Model) for Static Stance")
plt.tight_layout()
plt.show()
min_idx = np.unravel_index(np.argmin(Z), Z.shape)
print("Optimal knee angle:", angles_k[min_idx[0]], "Optimal ankle angle:", ankles_a[min_idx[1]])

# --- Dynamic "One Stride" Simulation (Deinonychus) ---
"""
    Simulate one normalized stride for Deinonychus and produce
    joint angle and quadriceps-force plots plus summary metrics.
"""
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec

# ========== Utilities ==========
def smooth_keyframe_curve(t, key_ts, key_vals):
    """Cosine-eased interpolation through keyframes."""
    t = np.asarray(t); key_ts = np.asarray(key_ts); key_vals = np.asarray(key_vals)
    out = np.zeros_like(t, dtype=float)
    for i in range(len(key_ts) - 1):
        mask = (t >= key_ts[i]) & (t <= key_ts[i+1])
        if not np.any(mask):
            continue
        u = (t[mask] - key_ts[i]) / (key_ts[i+1] - key_ts[i])      # 0..1
        s = 0.5 - 0.5*np.cos(np.pi*u)                              # cosine ease
        out[mask] = key_vals[i] + s*(key_vals[i+1] - key_vals[i])
    return out

def smoothstep01(x):
    """Cubic smoothstep clamped to [0,1]."""
    x = np.clip(x, 0.0, 1.0)
    return x*x*(3 - 2*x)

def fk_points(model, th_h_deg, th_k_deg, th_a_deg, th_mtp_deg):
    """Forward-kinematics points: hip -> knee -> ankle -> mtp -> toe."""
    th_h, th_k, th_a, th_mtp = map(np.radians, [th_h_deg, th_k_deg, th_a_deg, th_mtp_deg])
    th_tib = th_h - th_k
    th_met = th_tib - th_a
    th_pha = th_met - th_mtp
    hip   = np.array([0.0, 0.0])
    knee  = hip   + np.array([model.femur_length*np.cos(th_h),   model.femur_length*np.sin(th_h)])
    ankle = knee  + np.array([model.tibia_length*np.cos(th_tib), model.tibia_length*np.sin(th_tib)])
    mtp   = ankle + np.array([model.met_length*np.cos(th_met),   model.met_length*np.sin(th_met)])
    toe   = mtp   + np.array([model.pha_length*np.cos(th_pha),   model.pha_length*np.sin(th_pha)])
    return hip, knee, ankle, mtp, toe

# ========== 1) Species setup ==========
species_name = "Deinonychus antirrhopus"

dein = Animal(
    femur_length=1.0, tibia_length=1.31242, met_length=0.46217, pha_length=0.41785,
    thetaH=25, thetaA=20, thetaMTP=-10, CoP_fraction=0.5,
    CoMx=-0.05, CoMy=0.25, patellar_tendon_MA=0.0656
)

# Time grid (one normalized stride)
t = np.linspace(0.0, 1.0, 200)

# Duty factor (stance fraction of stride)
duty = 0.45
stance_mask = (t <= duty)

# Passive knee support
k1, k3, knee_rest = 0.7, 0.1, 55.0
DEADBAND_DEG = 5.0
# Keyframed joint trajectories (deg) D. antirrhopus
key_t = [0.00, 0.20, 0.40, 0.60, 0.80, 1.00]
theta_h   = smooth_keyframe_curve(t, key_t, [-30, -45, -75, -95, -60, -30])   # Hip
theta_k   = smooth_keyframe_curve(t, key_t, [105,  95,  40,  50,  85, 105])   # Knee
theta_a   = smooth_keyframe_curve(t, key_t, [ -80, -85, -10, -40, -95, -80])  # Ankle
theta_mtp = smooth_keyframe_curve(t, key_t, [ -55, -50, -90,   0,  30, -55])  # MTP

# ========== 2) GRF profile (BW-normalized) ==========
BW_peak = 1.0            # peak vertical GRF in body-weights
edge    = 0.04           # smooth taper (~4% stride) for heel-strike/toe-off

# Half-sine over stance [0, duty] with softened edges
phase   = np.clip((t / duty) * np.pi, 0.0, np.pi)
GRF_mag = BW_peak * np.sin(phase) * stance_mask.astype(float)
on  = smoothstep01((t - 0.0) / edge)
off = 1.0 - smoothstep01((t - duty) / edge)
GRF_mag *= on * off

# ========== 3) Simulate over stride ==========
M_req, M_pass, M_tot, F_quad = [], [], [], []

for i in range(len(t)):
    dein.thetaH   = float(theta_h[i])
    dein.thetaA   = float(theta_a[i])
    dein.thetaMTP = float(theta_mtp[i])
    dein.GRF      = float(GRF_mag[i])                 # BW-normalized magnitude

    # External (GRF-driven) moment
    m_req  = dein.compute_torque(float(theta_k[i]))

    # Passive elastic support with slack + load gating
    d_deg  = float(theta_k[i] - knee_rest)
    if abs(d_deg) <= DEADBAND_DEG:
        d_eff = 0.0
    else:
        d_eff = np.radians(np.sign(d_deg) * (abs(d_deg) - DEADBAND_DEG))
    m_pass_raw = k1*d_eff + k3*(d_eff**3)

    # Gate passive torque by load (goes to ~0 in swing)
    alpha = smoothstep01(GRF_mag[i] / (BW_peak + 1e-12))  # 0..1
    m_pass = alpha * m_pass_raw

    # Net moment & quadriceps force
    m_tot  = m_req - m_pass
    f_quad = abs(m_tot) / dein.patellar_tendon_MA

    M_req.append(m_req);  M_pass.append(m_pass); M_tot.append(m_tot); F_quad.append(f_quad)

# Convert to arrays, and zero swing-phase muscle force (no active load in swing)
M_req = np.array(M_req); M_pass = np.array(M_pass)
M_tot = np.array(M_tot); F_quad = np.array(F_quad)
F_quad[~stance_mask] = 0.0

# Dimensionless moment for cross-size comparison
Lfem = dein.femur_length
M_dimless = M_tot / (BW_peak * Lfem + 1e-12)

# ========== 4) Integrated metrics (stance only) ==========
s = stance_mask
W_torque = np.trapz(np.abs(M_tot[s]), t[s])                 # |M| integral over stance
avg_M    = np.mean(np.abs(M_tot[s]));  peak_M   = np.max(np.abs(M_tot[s]))
avg_F    = np.mean(F_quad[s]);           peak_F = np.max(F_quad[s])
avg_Mdl  = np.mean(np.abs(M_dimless[s])); peak_Mdl = np.max(np.abs(M_dimless[s]))
mean_BW  = np.mean(GRF_mag[s]);           peak_BW  = np.max(GRF_mag[s])

# ========= 5) Plot (no knee-moment panel) — Deinonychus =========
fig = plt.figure(figsize=(14, 9), dpi=450, constrained_layout=True)
gs  = gridspec.GridSpec(3, 1, height_ratios=[0.55, 1.25, 1.1], figure=fig)

F_YLIM = (0.0, 11.0)  # keep force limits for comparability

# (A) Stick figures
ax0 = fig.add_subplot(gs[0])
ax0.axhline(0, color='0.6', lw=1)
snap_ts = np.array([0.00, 0.20, 0.40, 0.60, 0.80, 1.00])
idxs    = (snap_ts * (len(t)-1)).astype(int)
spacing = dein.femur_length * 3.0
all_x, all_y = [], []
for n, i in enumerate(idxs):
    hip, knee, ankle, mtp, toe = fk_points(dein, theta_h[i], theta_k[i], theta_a[i], theta_mtp[i])
    shift = np.array([n*spacing, 0.0])
    hip, knee, ankle, mtp, toe = [p + shift for p in (hip, knee, ankle, mtp, toe)]
    pts = np.vstack([hip, knee, ankle, mtp, toe])
    all_x.append(pts[:,0]); all_y.append(pts[:,1])
    ax0.plot([hip[0],  knee[0]],  [hip[1],  knee[1]],  'k', lw=2.2)
    ax0.plot([knee[0], ankle[0]],[knee[1], ankle[1]], 'k', lw=2.2)
    ax0.plot([ankle[0], mtp[0]], [ankle[1], mtp[1]],  'k', lw=2.2)
    ax0.plot([mtp[0],  toe[0]],  [mtp[1],  toe[1]],   'k', lw=2.2)
all_x = np.concatenate(all_x); all_y = np.concatenate(all_y)
ax0.set_aspect('equal', adjustable='box')
ax0.set_xlim(all_x.min() - 0.18*spacing, all_x.max() + 0.18*spacing)
ax0.set_ylim(all_y.min() - 0.22*dein.femur_length, all_y.max() + 0.22*dein.femur_length)
ax0.set_title(f"Leg Segment Modeling at Selected Stride Times — {species_name}")
ax0.set_ylabel("height (arb.)"); ax0.set_xticks([]); ax0.set_yticks([])

# (B) Joint angles
ax1 = fig.add_subplot(gs[1])
ax1.plot(t, theta_k, label='Knee')
ax1.plot(t, theta_a, label='Ankle')
ax1.plot(t, theta_h, label='Hip', ls='--')
ax1.plot(t, theta_mtp, label='MTP', ls=':')
ax1.set_ylabel('Angle (°)')
ax1.set_title('Joint Angles Across One Stride')
ax1.legend(loc='upper right')

# (C) Quadriceps force ONLY
ax2 = fig.add_subplot(gs[2])
ax2.plot(t, F_quad, label='F_quad')
ax2.fill_between(t, 0, F_quad, where=stance_mask, color='orange', alpha=0.22)
ax2.set_xlabel('Stride Fraction (t)')
ax2.set_ylabel('Quadriceps Force (a.u.)')
ax2.set_title('Quadriceps Force Over One Stride')
ax2.set_ylim(*F_YLIM)

# Annotations on the force plot
mid_t = duty/2.0; toe_t = duty
ax2.set_xlim(0, 1)
ax2.axvline(mid_t, color='0.25', ls='--', lw=1.2)
ax2.axvline(toe_t, color='0.25', ls='--', lw=1.2)
ymax = ax2.get_ylim()[1]
ax2.text(mid_t, ymax*0.95, "Mid-stance", ha='center', va='top', fontsize=9, color='0.25')
ax2.text(toe_t, ymax*0.95, "Toe-off",    ha='center', va='top', fontsize=9, color='0.25')

plt.show()


# ========== 6) Text Report ==========
print(f"\n=== Stride Summary ({species_name}) ===")
print(f"Stance fraction (duty): {duty:.2f} of stride")
print(f"Peak vertical GRF: {peak_BW:.2f} BW; Mean over stance: {mean_BW:.2f} BW")
print(f"Integrated knee 'work' (|M_tot| over stance): {W_torque:.3f} a.u.")
print(f"Mean |knee moment| during stance: {avg_M:.3f} a.u. (dimensionless {avg_Mdl:.3f})")
print(f"Peak |knee moment| during stance: {peak_M:.3f} a.u. (dimensionless {peak_Mdl:.3f})")
print(f"Mean quadriceps force during stance: {avg_F:.3f} a.u.")
print(f"Peak quadriceps force during stance: {peak_F:.3f} a.u.")

# --- Dynamic "One Stride" Simulation (Struthio camelus) ---
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec

# ========= Utilities (same as Deinonychus block) =========
def smooth_keyframe_curve(t, key_ts, key_vals):
    t = np.asarray(t); key_ts = np.asarray(key_ts); key_vals = np.asarray(key_vals)
    out = np.zeros_like(t, dtype=float)
    for i in range(len(key_ts) - 1):
        mask = (t >= key_ts[i]) & (t <= key_ts[i+1])
        if not np.any(mask):
            continue
        u = (t[mask] - key_ts[i]) / (key_ts[i+1] - key_ts[i])
        s = 0.5 - 0.5*np.cos(np.pi*u)
        out[mask] = key_vals[i] + s*(key_vals[i+1] - key_vals[i])
    return out

def smoothstep01(x):
    x = np.clip(x, 0.0, 1.0)
    return x*x*(3 - 2*x)

def fk_points(model, th_h_deg, th_k_deg, th_a_deg, th_mtp_deg):
    th_h, th_k, th_a, th_mtp = map(np.radians, [th_h_deg, th_k_deg, th_a_deg, th_mtp_deg])
    th_tib = th_h - th_k
    th_met = th_tib - th_a
    th_pha = th_met - th_mtp
    hip   = np.array([0.0, 0.0])
    knee  = hip   + np.array([ost.femur_length*np.cos(th_h),   ost.femur_length*np.sin(th_h)])
    ankle = knee  + np.array([ost.tibia_length*np.cos(th_tib), ost.tibia_length*np.sin(th_tib)])
    mtp   = ankle + np.array([ost.met_length*np.cos(th_met),   ost.met_length*np.sin(th_met)])
    toe   = mtp   + np.array([ost.pha_length*np.cos(th_pha),   ost.pha_length*np.sin(th_pha)])
    return hip, knee, ankle, mtp, toe

# ========= 1) Species setup =========
species_name = "Struthio camelus"

ost = Animal(
    femur_length=1.0, tibia_length=1.71850, met_length=1.53003, pha_length=0.51851,
    thetaH=35, thetaA=20, thetaMTP=-10, CoP_fraction=0.5,
    CoMx=+0.08, CoMy=0.30, patellar_tendon_MA=0.090
)

# Time grid
t = np.linspace(0.0, 1.0, 200)

# Duty factor (stance fraction)
duty = 0.40
stance_mask = (t <= duty)

# Passive knee (ostrich-tuned) + tendon slack deadband
k1, k3, knee_rest = 0.6, 0.1, 32.0
DEADBAND_DEG = 5.0

# Keyframed joint trajectories (deg) — ostrich
key_t = [0.00, 0.50, 0.75, 1.00]
theta_h   = smooth_keyframe_curve(t, key_t, [-40, -50, -45, -40])   # Hip
theta_k   = smooth_keyframe_curve(t, key_t, [ 47,  90,  90,  47])   # Knee
theta_a   = smooth_keyframe_curve(t, key_t, [ -10, -45, -90, -10])  # Ankle
theta_mtp = smooth_keyframe_curve(t, key_t, [ -73,  15,  30, -73])  # MTP

# ========= 2) GRF profile (BW-normalized) =========
BW_peak = 1.0
edge    = 0.04

phase   = np.clip((t / duty) * np.pi, 0.0, np.pi)
GRF_mag = BW_peak * np.sin(phase) * stance_mask.astype(float)
on  = smoothstep01((t - 0.0) / edge)
off = 1.0 - smoothstep01((t - duty) / edge)
GRF_mag *= on * off

# ========= 3) Simulate =========
M_req, M_pass, M_tot, F_quad = [], [], [], []

for i in range(len(t)):
    ost.thetaH   = float(theta_h[i])
    ost.thetaA   = float(theta_a[i])
    ost.thetaMTP = float(theta_mtp[i])
    ost.GRF      = float(GRF_mag[i])

    # External (GRF-driven) moment
    m_req = ost.compute_torque(float(theta_k[i]))

    # Passive elastic with slack + load gating
    d_deg = float(theta_k[i] - knee_rest)
    if abs(d_deg) <= DEADBAND_DEG:
        d_eff = 0.0
    else:
        d_eff = np.radians(np.sign(d_deg) * (abs(d_deg) - DEADBAND_DEG))
    m_pass_raw = k1*d_eff + k3*(d_eff**3)

    alpha = smoothstep01(GRF_mag[i] / (BW_peak + 1e-12))  # gate by load (≈0 in swing)
    m_pass = alpha * m_pass_raw

    # Net moment & quadriceps force
    m_tot  = m_req - m_pass
    f_quad = abs(m_tot) / ost.patellar_tendon_MA

    M_req.append(m_req); M_pass.append(m_pass); M_tot.append(m_tot); F_quad.append(f_quad)

M_req = np.array(M_req); M_pass = np.array(M_pass)
M_tot = np.array(M_tot); F_quad = np.array(F_quad)

# Zero muscle load in swing
F_quad[~stance_mask] = 0.0

# Dimensionless knee moment
Lfem = ost.femur_length
M_dimless = M_tot / (BW_peak * Lfem + 1e-12)

# ========= 4) Integrated metrics (stance only) =========
s = stance_mask
W_torque = np.trapz(np.abs(M_tot[s]), t[s])
avg_M    = np.mean(np.abs(M_tot[s]));  peak_M   = np.max(np.abs(M_tot[s]))
avg_F    = np.mean(F_quad[s]);         peak_F   = np.max(F_quad[s])
avg_Mdl  = np.mean(np.abs(M_dimless[s])); peak_Mdl = np.max(np.abs(M_dimless[s]))
mean_BW  = np.mean(GRF_mag[s]);        peak_BW  = np.max(GRF_mag[s])

# ========= 5) Plot (no knee-moment panel) =========
fig = plt.figure(figsize=(14, 9), dpi=450, constrained_layout=True)
gs  = gridspec.GridSpec(3, 1, height_ratios=[0.55, 1.25, 1.1], figure=fig)

F_YLIM = (0.0, 11.0)  # keep force limits for comparability

# (A) Stick figures
ax0 = fig.add_subplot(gs[0])
ax0.axhline(0, color='0.6', lw=1)
snap_ts = np.array([0.00, 0.50, 0.75, 1.00])
idxs    = (snap_ts * (len(t)-1)).astype(int)
spacing = ost.femur_length * 3.0
all_x, all_y = [], []
for n, i in enumerate(idxs):
    hip, knee, ankle, mtp, toe = fk_points(ost, theta_h[i], theta_k[i], theta_a[i], theta_mtp[i])
    shift = np.array([n*spacing, 0.0])
    hip, knee, ankle, mtp, toe = [p + shift for p in (hip, knee, ankle, mtp, toe)]
    pts = np.vstack([hip, knee, ankle, mtp, toe])
    all_x.append(pts[:,0]); all_y.append(pts[:,1])
    ax0.plot([hip[0],  knee[0]],  [hip[1],  knee[1]],  'k', lw=2.2)
    ax0.plot([knee[0], ankle[0]],[knee[1], ankle[1]], 'k', lw=2.2)
    ax0.plot([ankle[0], mtp[0]], [ankle[1], mtp[1]],  'k', lw=2.2)
    ax0.plot([mtp[0],  toe[0]],  [mtp[1],  toe[1]],   'k', lw=2.2)
all_x = np.concatenate(all_x); all_y = np.concatenate(all_y)
ax0.set_aspect('equal', adjustable='box')
ax0.set_xlim(all_x.min() - 0.18*spacing, all_x.max() + 0.18*spacing)
ax0.set_ylim(all_y.min() - 0.22*ost.femur_length, all_y.max() + 0.22*ost.femur_length)
ax0.set_title(f"Leg Segment Modeling at Selected Stride Times — {species_name}")
ax0.set_ylabel("height (arb.)"); ax0.set_xticks([]); ax0.set_yticks([])

# (B) Joint angles
ax1 = fig.add_subplot(gs[1])
ax1.plot(t, theta_k, label='Knee')
ax1.plot(t, theta_a, label='Ankle')
ax1.plot(t, theta_h, label='Hip', ls='--')
ax1.plot(t, theta_mtp, label='MTP', ls=':')
ax1.set_ylabel('Angle (°)')
ax1.set_title('Joint Angles Across One Stride')
ax1.legend(loc='upper right')

# (C) Quadriceps force ONLY
ax2 = fig.add_subplot(gs[2])
ax2.plot(t, F_quad, label='F_quad')
ax2.fill_between(t, 0, F_quad, where=stance_mask, color='orange', alpha=0.22)
ax2.set_xlabel('Stride Fraction (t)')
ax2.set_ylabel('Quadriceps Force (a.u.)')
ax2.set_title('Quadriceps Force Over One Stride')
ax2.set_ylim(*F_YLIM)

# Annotations on the force plot
mid_t = duty/2.0; toe_t = duty
ax2.set_xlim(0, 1)
ax2.axvline(mid_t, color='0.25', ls='--', lw=1.2)
ax2.axvline(toe_t, color='0.25', ls='--', lw=1.2)
ymax = ax2.get_ylim()[1]
ax2.text(mid_t, ymax*0.95, "Mid-stance", ha='center', va='top', fontsize=9, color='0.25')
ax2.text(toe_t, ymax*0.95, "Toe-off",    ha='center', va='top', fontsize=9, color='0.25')

plt.show()


# ========= 6) Text Report =========
print(f"\n=== Stride Summary ({species_name}) ===")
print(f"Stance fraction (duty): {duty:.2f} of stride")
print(f"Peak vertical GRF: {peak_BW:.2f} BW; Mean over stance: {mean_BW:.2f} BW")
print(f"Integrated knee 'work' (|M_tot| over stance): {W_torque:.3f} a.u.")
print(f"Mean |knee moment| during stance: {avg_M:.3f} a.u. (dimensionless {avg_Mdl:.3f})")
print(f"Peak |knee moment| during stance: {peak_M:.3f} a.u. (dimensionless {peak_Mdl:.3f})")
print(f"Mean quadriceps force during stance: {avg_F:.3f} a.u.")
print(f"Peak quadriceps force during stance: {peak_F:.3f} a.u.")

# ================= Fix CoM bars: force sweep, robust labels, outline zero-height bars =================
import numpy as np
import matplotlib.pyplot as plt

# ---- assumes: Animal class, model (dein/ost) + t, duty, theta_* + k1,k3,knee_rest exist; else we create defaults
def smoothstep01(x):
    x = np.clip(x, 0.0, 1.0)
    return x*x*(3 - 2*x)

EDGE_TAPER = 0.04

# pick a model or build Deinonychus
if 'dein' in globals():
    model = dein; species = "Deinonychus"


if not all(k in globals() for k in ['t','theta_h','theta_k','theta_a','theta_mtp','duty']):
    t = np.linspace(0,1,200)
    if species == "Deinonychus":
        duty = 0.45
        key_t = [0.00,0.20,0.40,0.60,0.80,1.00]
        theta_h   = np.interp(t,key_t,[-30,-45,-75,-95,-60,-30])
        theta_k   = np.interp(t,key_t,[105, 95, 40, 50, 85,105])
        theta_a   = np.interp(t,key_t,[ -80,-85,-10,-40,-95,-80])
        theta_mtp = np.interp(t,key_t,[ -55,-50,-90,  0, 30,-55])
        k1,k3,knee_rest = 0.7,0.1,55.0

def run_stride_once(model, duty_val, knee_rest_val, GRF_peak=1.0):
    phase   = np.clip((t / duty_val) * np.pi, 0.0, np.pi)
    GRF_mag = GRF_peak * np.sin(phase) * (t <= duty_val).astype(float)
    on  = smoothstep01((t - 0.0)       / EDGE_TAPER)
    off = 1.0 - smoothstep01((t - duty_val) / EDGE_TAPER)
    GRF_mag *= on * off

    M_tot, Fq = [], []
    for i in range(len(t)):
        model.thetaH, model.thetaA, model.thetaMTP = float(theta_h[i]), float(theta_a[i]), float(theta_mtp[i])
        model.GRF = float(GRF_mag[i])
        m_req  = model.compute_torque(float(theta_k[i]))
        d_rad  = np.radians(theta_k[i] - knee_rest_val)
        m_pass = k1*d_rad + k3*(d_rad**3)
        m_tot  = m_req - m_pass
        M_tot.append(m_tot)
        Fq.append(abs(m_tot) / model.patellar_tendon_MA)
    M_tot = np.asarray(M_tot); Fq = np.asarray(Fq); s = (t <= duty_val)
    return M_tot, Fq, s

# Baseline
M0, F0, s0 = run_stride_once(model, duty, knee_rest)
base_peakM = float(np.max(np.abs(M0[s0])))
base_meanF = float(np.mean(F0[s0]))

# ---- Sweeps (force CoM sweep; use ASCII 'CoMx' to avoid unicode mismatch) ----
records = []  # (label, dPk%, dMn%)

# 1) CoMx ±Δ (boosted to ±25% so it’s visible if 0-line overlap was the issue)
SWEEP_COM = 0.25
orig_CoMx = model.CoMx
for scale in [1.0 - SWEEP_COM, 1.0 + SWEEP_COM]:
    model.CoMx = orig_CoMx * scale
    Mi, Fi, si = run_stride_once(model, duty, knee_rest)
    dPk = 100.0 * (np.max(np.abs(Mi[si])) - base_peakM) / (base_peakM + 1e-12)
    dMn = 100.0 * (np.mean(Fi[si])      - base_meanF)  / (base_meanF  + 1e-12)
    records.append((f"CoMx {int((scale-1)*100):+d}%", dPk, dMn))
model.CoMx = orig_CoMx

# 2) rPT ±10%
orig_rPT = model.patellar_tendon_MA
for scale in [0.9, 1.1]:
    model.patellar_tendon_MA = orig_rPT * scale
    Mi, Fi, si = run_stride_once(model, duty, knee_rest)
    dPk = 100.0 * (np.max(np.abs(Mi[si])) - base_peakM) / (base_peakM + 1e-12)
    dMn = 100.0 * (np.mean(Fi[si])      - base_meanF)  / (base_meanF  + 1e-12)
    records.append((f"rPT {int((scale-1)*100):+d}%", dPk, dMn))
model.patellar_tendon_MA = orig_rPT

# 3) knee_rest ±10°
orig_rest = knee_rest
for ddeg in [-10.0, 10.0]:
    knee_rest = orig_rest + ddeg
    Mi, Fi, si = run_stride_once(model, duty, knee_rest)
    dPk = 100.0 * (np.max(np.abs(Mi[si])) - base_peakM) / (base_peakM + 1e-12)
    dMn = 100.0 * (np.mean(Fi[si])      - base_meanF)  / (base_meanF  + 1e-12)
    records.append((f"knee_rest {int(ddeg):+d}°", dPk, dMn))
knee_rest = orig_rest

# ---- DEBUG: show what we’re about to plot ----
print("Labels:", [lbl for (lbl,_,_) in records])

# ---- Group & plot (outline bars so 0-height bars are still visible) ----
groups = {'CoMx': [], 'rPT': [], 'knee_rest': []}
for lbl, dPk, dMn in records:
    if lbl.startswith('CoMx'):        groups['CoMx'].append((lbl, dPk, dMn))
    elif lbl.startswith('rPT'):       groups['rPT'].append((lbl, dPk, dMn))
    elif lbl.startswith('knee_rest'):groups['knee_rest'].append((lbl, dPk, dMn))

def _minus_first(lbl): return 0 if ('-' in lbl.replace('−','-')) else 1
for g in groups: groups[g].sort(key=lambda x: (_minus_first(x[0]), x[0]))

labels = [lbl for g in ['CoMx','rPT','knee_rest'] for (lbl,_,_) in groups[g]]
dPkMs  = [dPk for g in ['CoMx','rPT','knee_rest'] for (_,dPk,_) in groups[g]]
dMnFs  = [dMn for g in ['CoMx','rPT','knee_rest'] for (_,_,dMn) in groups[g]]
colors = (['#4477AA']*len(groups['CoMx']) +
          ['#66AA55']*len(groups['rPT'])   +
          ['#CC6677']*len(groups['knee_rest']))

x = np.arange(len(labels))
# --- Single-panel version: Δ Mean F_quad (%) only ---
import matplotlib.patches as mpatches

# Define colors for legend
COLOR_COMX = '#4477AA'
COLOR_RPT  = '#66AA55'
COLOR_TRES = '#CC6677'

x = np.arange(len(labels))

# --- Single-panel version: Δ Mean F_quad (%) only (Enhanced) ---

# 1) Make a single axes (using 300 DPI for publication quality)
# Slightly increase figure width to better accommodate labels
fig, ax2 = plt.subplots(figsize=(8.5, 5), dpi=300, constrained_layout=True)

# 2) Plot Mean F_quad bars - need separate calls for legend
# Calculate indices for plotting
idx_CoMx   = np.arange(len(groups['CoMx']))
idx_rPT    = np.arange(len(groups['rPT'])) + len(groups['CoMx'])
idx_t_rest = np.arange(len(groups['knee_rest'])) + len(groups['CoMx']) + len(groups['rPT'])

# Plot each group separately to generate legend handles
bar_comx = ax2.bar(x[idx_CoMx], dMnFs[:len(groups['CoMx'])], color=COLOR_COMX, edgecolor='k', linewidth=0.6,
        label='Center of Mass Position ($CoM_x$)')
bar_rpt = ax2.bar(x[idx_rPT], dMnFs[len(groups['CoMx']):len(groups['CoMx'])+len(groups['rPT'])], color=COLOR_RPT, edgecolor='k', linewidth=0.6,
        label='Patellar Tendon Moment Arm ($r_{PT}$)')
bar_trest = ax2.bar(x[idx_t_rest], dMnFs[len(groups['CoMx'])+len(groups['rPT']):], color=COLOR_TRES, edgecolor='k', linewidth=0.6,
        label='Resting Knee Angle ($\theta_{rest}$)')

# Horizontal zero line
ax2.axhline(0, color='0.2', lw=1.6, ls='--')

# Labels and Title
ax2.set_ylabel("Percent Change in Mean Quadriceps Force ($\\Delta F_{quad}$) (%)", fontsize=12, fontweight='bold')
ax2.set_xticks(x)
# Use a slightly larger rotation for long labels
ax2.set_xticklabels(labels, rotation=35, ha='right', fontsize=10)
ax2.set_xlabel("Parameter Perturbation", fontsize=12)

# Enhanced Title: Summarize the finding clearly in the title/subtitle
ax2.set_title(f"Sensitivity Analysis: {species} \n"
              "Percent change in mean quadriceps force vs baseline", fontsize=13, loc='center')


# 3) Annotate near-zero bars (robustly outlining them as well)
for xi, v in zip(x, dMnFs):
    if abs(v) < 0.15:
        y_pos = 0.2 if v >= 0 else -0.2
        ax2.text(xi, y_pos, f"{v:+.1f}%",
                 ha='center', va='bottom', fontsize=9, color='0.3', fontweight='bold')

# 4) Y-limits padding for visibility
# Recalculate padding based on max absolute value
abs_max_val = max(1, np.max(np.abs(dMnFs)))
pad2 = 0.05 * abs_max_val + (1.0 if abs_max_val < 5 else 0) # Add 1% pad minimum if data is small
ax2.set_ylim(min(0, np.min(dMnFs)) - pad2, max(0, np.max(dMnFs)) + pad2)
ax2.tick_params(axis='both', which='major', labelsize=10) # Set general tick size

plt.show()

# (Optional) Print the values table
for lbl, dPk, dMn in records:
    print(lbl, f"{dMn:+.2f}%")

# ================= Fix CoM bars: force sweep, robust labels, outline zero-height bars =================
import numpy as np
import matplotlib.pyplot as plt


# ---- assumes: Animal class, model (dein/ost) + t, duty, theta_* + k1,k3,knee_rest exist; else we create defaults
def smoothstep01(x):
   x = np.clip(x, 0.0, 1.0)
   return x*x*(3 - 2*x)


EDGE_TAPER = 0.04


# pick a model or build Deinonychus
if 'ost' in globals():
   model = ost; species = "Ostrich"




if not all(k in globals() for k in ['t','theta_h','theta_k','theta_a','theta_mtp','duty']):
   t = np.linspace(0,1,200)
   if species == "Ostrich":
       duty = 0.45
       key_t = [0.00, 0.50, 0.75, 1.00]
       theta_h   = np.interp(t,key_t,[-40, -50, -45, -40])
       theta_k   = np.interp(t,key_t,[ 47,  90,  90,  47])
       theta_a   = np.interp(t,key_t,[ -10, -45, -90, -10])
       theta_mtp = np.interp(t,key_t,[ -73,  15,  30, -73])
       k1,k3,knee_rest = 0.6,0.1,32.0




def run_stride_once(model, duty_val, knee_rest_val, GRF_peak=1.0):
   phase   = np.clip((t / duty_val) * np.pi, 0.0, np.pi)
   GRF_mag = GRF_peak * np.sin(phase) * (t <= duty_val).astype(float)
   on  = smoothstep01((t - 0.0)       / EDGE_TAPER)
   off = 1.0 - smoothstep01((t - duty_val) / EDGE_TAPER)
   GRF_mag *= on * off


   M_tot, Fq = [], []
   for i in range(len(t)):
       model.thetaH, model.thetaA, model.thetaMTP = float(theta_h[i]), float(theta_a[i]), float(theta_mtp[i])
       model.GRF = float(GRF_mag[i])
       m_req  = model.compute_torque(float(theta_k[i]))
       d_rad  = np.radians(theta_k[i] - knee_rest_val)
       m_pass = k1*d_rad + k3*(d_rad**3)
       m_tot  = m_req - m_pass
       M_tot.append(m_tot)
       Fq.append(abs(m_tot) / model.patellar_tendon_MA)
   M_tot = np.asarray(M_tot); Fq = np.asarray(Fq); s = (t <= duty_val)
   return M_tot, Fq, s


# Baseline
M0, F0, s0 = run_stride_once(model, duty, knee_rest)
base_peakM = float(np.max(np.abs(M0[s0])))
base_meanF = float(np.mean(F0[s0]))


# ---- Sweeps (force CoM sweep; use ASCII 'CoMx' to avoid unicode mismatch) ----
records = []  # (label, dPk%, dMn%)


# 1) CoMx ±Δ (boosted to ±25% so it’s visible if 0-line overlap was the issue)
SWEEP_COM = 0.25
orig_CoMx = model.CoMx
for scale in [1.0 - SWEEP_COM, 1.0 + SWEEP_COM]:
   model.CoMx = orig_CoMx * scale
   Mi, Fi, si = run_stride_once(model, duty, knee_rest)
   dPk = 100.0 * (np.max(np.abs(Mi[si])) - base_peakM) / (base_peakM + 1e-12)
   dMn = 100.0 * (np.mean(Fi[si])      - base_meanF)  / (base_meanF  + 1e-12)
   records.append((f"CoMx {int((scale-1)*100):+d}%", dPk, dMn))
model.CoMx = orig_CoMx


# 2) rPT ±10%
orig_rPT = model.patellar_tendon_MA
for scale in [0.9, 1.1]:
   model.patellar_tendon_MA = orig_rPT * scale
   Mi, Fi, si = run_stride_once(model, duty, knee_rest)
   dPk = 100.0 * (np.max(np.abs(Mi[si])) - base_peakM) / (base_peakM + 1e-12)
   dMn = 100.0 * (np.mean(Fi[si])      - base_meanF)  / (base_meanF  + 1e-12)
   records.append((f"rPT {int((scale-1)*100):+d}%", dPk, dMn))
model.patellar_tendon_MA = orig_rPT


# 3) knee_rest ±10°
orig_rest = knee_rest
for ddeg in [-10.0, 10.0]:
   knee_rest = orig_rest + ddeg
   Mi, Fi, si = run_stride_once(model, duty, knee_rest)
   dPk = 100.0 * (np.max(np.abs(Mi[si])) - base_peakM) / (base_peakM + 1e-12)
   dMn = 100.0 * (np.mean(Fi[si])      - base_meanF)  / (base_meanF  + 1e-12)
   records.append((f"knee_rest {int(ddeg):+d}°", dPk, dMn))
knee_rest = orig_rest


# ---- DEBUG: show what we’re about to plot ----
print("Labels:", [lbl for (lbl,_,_) in records])


# ---- Group & plot (outline bars so 0-height bars are still visible) ----
groups = {'CoMx': [], 'rPT': [], 'knee_rest': []}
for lbl, dPk, dMn in records:
   if lbl.startswith('CoMx'):        groups['CoMx'].append((lbl, dPk, dMn))
   elif lbl.startswith('rPT'):       groups['rPT'].append((lbl, dPk, dMn))
   elif lbl.startswith('knee_rest'):groups['knee_rest'].append((lbl, dPk, dMn))


def _minus_first(lbl): return 0 if ('-' in lbl.replace('−','-')) else 1
for g in groups: groups[g].sort(key=lambda x: (_minus_first(x[0]), x[0]))


labels = [lbl for g in ['CoMx','rPT','knee_rest'] for (lbl,_,_) in groups[g]]
dPkMs  = [dPk for g in ['CoMx','rPT','knee_rest'] for (_,dPk,_) in groups[g]]
dMnFs  = [dMn for g in ['CoMx','rPT','knee_rest'] for (_,_,dMn) in groups[g]]
colors = (['#4477AA']*len(groups['CoMx']) +
         ['#66AA55']*len(groups['rPT'])   +
         ['#CC6677']*len(groups['knee_rest']))


x = np.arange(len(labels))
# --- Single-panel version: Δ Mean F_quad (%) only ---
import matplotlib.patches as mpatches


# Define colors for legend
COLOR_COMX = '#4477AA'
COLOR_RPT  = '#66AA55'
COLOR_TRES = '#CC6677'


x = np.arange(len(labels))


# --- Single-panel version: Δ Mean F_quad (%) only (Enhanced) ---


# 1) Make a single axes (using 300 DPI for publication quality)
# Slightly increase figure width to better accommodate labels
fig, ax2 = plt.subplots(figsize=(8.5, 5), dpi=300, constrained_layout=True)


# 2) Plot Mean F_quad bars - need separate calls for legend
# Calculate indices for plotting
idx_CoMx   = np.arange(len(groups['CoMx']))
idx_rPT    = np.arange(len(groups['rPT'])) + len(groups['CoMx'])
idx_t_rest = np.arange(len(groups['knee_rest'])) + len(groups['CoMx']) + len(groups['rPT'])


# Plot each group separately to generate legend handles
bar_comx = ax2.bar(x[idx_CoMx], dMnFs[:len(groups['CoMx'])], color=COLOR_COMX, edgecolor='k', linewidth=0.6,
       label='Center of Mass Position ($CoM_x$)')
bar_rpt = ax2.bar(x[idx_rPT], dMnFs[len(groups['CoMx']):len(groups['CoMx'])+len(groups['rPT'])], color=COLOR_RPT, edgecolor='k', linewidth=0.6,
       label='Patellar Tendon Moment Arm ($r_{PT}$)')
bar_trest = ax2.bar(x[idx_t_rest], dMnFs[len(groups['CoMx'])+len(groups['rPT']):], color=COLOR_TRES, edgecolor='k', linewidth=0.6,
       label='Resting Knee Angle ($\theta_{rest}$)')


# Horizontal zero line
ax2.axhline(0, color='0.2', lw=1.6, ls='--')


# Labels and Title
ax2.set_ylabel("Percent Change in Mean Quadriceps Force ($\\Delta F_{quad}$) (%)", fontsize=12, fontweight='bold')
ax2.set_xticks(x)
# Use a slightly larger rotation for long labels
ax2.set_xticklabels(labels, rotation=35, ha='right', fontsize=10)
ax2.set_xlabel("Parameter Perturbation", fontsize=12)


# Enhanced Title: Summarize the finding clearly in the title/subtitle
ax2.set_title(f"Sensitivity Analysis: {species} \n"
             "Percent change in mean quadriceps force vs baseline", fontsize=13, loc='center')




# 3) Annotate near-zero bars (robustly outlining them as well)
for xi, v in zip(x, dMnFs):
   if abs(v) < 0.15:
       y_pos = 0.2 if v >= 0 else -0.2
       ax2.text(xi, y_pos, f"{v:+.1f}%",
                ha='center', va='bottom', fontsize=9, color='0.3', fontweight='bold')


# 4) Y-limits padding for visibility
# Recalculate padding based on max absolute value
abs_max_val = max(1, np.max(np.abs(dMnFs)))
pad2 = 0.05 * abs_max_val + (1.0 if abs_max_val < 5 else 0) # Add 1% pad minimum if data is small
ax2.set_ylim(min(0, np.min(dMnFs)) - pad2, max(0, np.max(dMnFs)) + pad2)
ax2.tick_params(axis='both', which='major', labelsize=10) # Set general tick size


plt.show()


# (Optional) Print the values table
for lbl, dPk, dMn in records:
   print(lbl, f"{dMn:+.2f}%")